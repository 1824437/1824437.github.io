<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>经历过浏览器标准之乱，又TM正在经历终端之乱及所带来的框架之乱</title>
  
  <subtitle>ZhuTao&#39;s Blog&lt;zhutao@live.cn&gt;</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="1824437.github.io/"/>
  <updated>2019-11-01T02:57:43.537Z</updated>
  <id>1824437.github.io/</id>
  
  <author>
    <name>ZhuTao&lt;zhutao@live.cn&gt;</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flex</title>
    <link href="1824437.github.io/web/css/flex/"/>
    <id>1824437.github.io/web/css/flex/</id>
    <published>2019-11-01T02:57:06.699Z</published>
    <updated>2019-11-01T02:57:43.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器与项目（容器成员）"><a href="#容器与项目（容器成员）" class="headerlink" title="容器与项目（容器成员）"></a>容器与项目（容器成员）</h2><h3 id="flex-容器"><a href="#flex-容器" class="headerlink" title="flex 容器"></a>flex 容器</h3><p>设置为flex容器： <code>display:flex;</code></p><p><strong>属性</strong></p><ol><li><p>flex-direction 主轴方向</p><ul><li>row</li><li>row-reverse</li><li>column</li><li>column-reverse</li></ul></li></ol><ol start="2"><li><p>flex-warp 发生换行时的堆叠方向</p><ul><li>nowarp 不换行，会挤压item主轴方向</li><li>warp 换行，不会挤压item主辆方向，而是挤压交叉轴。</li><li>warp-reverse,同上，从下往上排。</li></ul></li><li><p>flex-flow flex-direction及flex-warp的缩写。</p><p> <flex-direction> <flex-warp>|initial|inherit</p></li><li><p>justify-content 主轴对齐方向</p><ul><li>flex-start</li><li>flex-end</li><li>center</li><li>space-between 平散对齐</li><li>space-around 每侧相隔相等</li></ul></li></ol><ol start="5"><li><p>align-items 交叉轴对齐方式</p><ul><li>flex-start</li><li>flex-end</li><li>center</li><li>baseline</li><li>stretch</li></ul></li><li><p>align-content</p></li></ol><h3 id="flex容器内的元素则为flex项目。"><a href="#flex容器内的元素则为flex项目。" class="headerlink" title="flex容器内的元素则为flex项目。"></a>flex容器内的元素则为flex项目。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;容器与项目（容器成员）&quot;&gt;&lt;a href=&quot;#容器与项目（容器成员）&quot; class=&quot;headerlink&quot; title=&quot;容器与项目（容器成员）&quot;&gt;&lt;/a&gt;容器与项目（容器成员）&lt;/h2&gt;&lt;h3 id=&quot;flex-容器&quot;&gt;&lt;a href=&quot;#flex-容器&quot; c
      
    
    </summary>
    
    
      <category term="web" scheme="1824437.github.io/categories/web/"/>
    
    
      <category term="css" scheme="1824437.github.io/tags/css/"/>
    
      <category term="flex" scheme="1824437.github.io/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/centos%E5%AD%A6%E4%B9%A0/"/>
    <id>1824437.github.io/os/centos学习/</id>
    <published>2019-10-29T06:26:52.595Z</published>
    <updated>2019-10-29T06:27:39.978Z</updated>
    
    <content type="html"><![CDATA[<h4 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h4><p>ip命令<a href="http://blog.csdn.net/hunyxv/article/details/51900482">http://blog.csdn.net/hunyxv/article/details/51900482</a><br>centOS网络相关<a href="http://blog.chinaunix.net/uid-26495963-id-3230810.html">http://blog.chinaunix.net/uid-26495963-id-3230810.html</a></p><p>-<br>####查看系统版本<br><code>cat /etc/redhat-release</code><br>####查看系统网络信息<br><code>ip addr</code>  设备及状态<br><code>ip -s link</code>查看网络接口的统计数据<br>####查看bash版本<br><code>bash -version</code><br>####查看哪个包提供了某个命令<br><code>yum provides &lt;commandname&gt;``yum whatprovides &lt;commandname&gt;</code><br>####vi切换到命令行<code>ctrl+z</code>,再切换到vi<code>fg</code><br>####包管理器yum  </p><p>1.<code>yum list installed</code>查看已安装的包</p><p>####有线网卡连接网络 </p><p><strong>!!!一定要注意网线连好了</strong> </p><ol><li>配置文件路径<code>/etc/sysconfig/network-script/ifcfg-&lt;ethernet name&gt;</code></li><li>配置项<code>ONBOOT=yes</code></li><li>通过<code>ip addr</code>查看网卡mac地址，在配置文件中增加<br> <code>HWADDR=00:0c:bd:05:4e:cc​</code></li><li>重启网卡服务<code>systemctl restart network``service network restart</code></li><li>设定开机启动服务<code>systemctl enable NetworkManager-wait-online.service</code></li></ol><p>####cenos命令行 设置字号  </p><p>修改<code>etc/vconsole.conf</code> 改字体即可<br><code>setfont &lt;fontname&gt;</code> 修改字体即可达到修改字号</p><p>####CentOS 7电源管理设置<br>配置文件: <code>/etc/systemd/logind.conf</code><br>配置项<code>HandleLidSwitch=lock</code> 合盖不休眠<br>配置完后重启配置, <code>systemctl restart systemd-logind</code>  </p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p><code>yum install git</code></p><h3 id="进入休眠状态"><a href="#进入休眠状态" class="headerlink" title="进入休眠状态"></a>进入休眠状态</h3><p><code>sudo pm-hibernate</code> //休眠<br><code>sudo pm-suspend</code><br><code>sudo pm-pm-suspend-hybrid</code></p><h3 id="创建账号及设置权限"><a href="#创建账号及设置权限" class="headerlink" title="创建账号及设置权限"></a>创建账号及设置权限</h3><p>系统的账号文件 /etc/passwd<br>用户组列表文件：/etc/group  </p><ol><li><p>创建账号 <code>adduser t.z</code></p></li><li><p>添加sudo仅限</p><p> sudoers文件 /etc/sudoers<br> 在root下增加一行，保存即可</p></li><li><p>切换用户 <code>su &lt;username&gt;</code></p></li><li><p>修改主机名 <code>hostnamectl set-hostname &lt;hostname&gt;</code></p></li><li><p>查看主机信息 hostnamectl status</p></li></ol><p>-</p><h2 id="install-software"><a href="#install-software" class="headerlink" title="install software"></a>install software</h2><h3 id="安装nginx-跳转"><a href="#安装nginx-跳转" class="headerlink" title="安装nginx 跳转"></a>安装nginx <a href="../nginx/centos安装nginx.md">跳转</a></h3><h3 id="安装epel源"><a href="#安装epel源" class="headerlink" title="安装epel源"></a>安装epel源</h3><p><code>sudo yum install epel-release</code></p><h3 id="安装nodejs-official-guide"><a href="#安装nodejs-official-guide" class="headerlink" title="安装nodejs official guide"></a>安装nodejs <a href="https://nodejs.org/en/download/package-manager/#header-enterprise-linux-and-fedora">official guide</a></h3><ol><li><code>curl --silent --location https://rpm.nodesource.com/setup_9.x | sudo bash -</code></li><li><code>sudo yum -y install nodejs</code></li></ol><h3 id="安装-yarn"><a href="#安装-yarn" class="headerlink" title="安装 yarn"></a>安装 yarn</h3><ol><li><code>curl -sL https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</code></li><li><code>sudo yum install yarn</code></li></ol><h3 id="install-rsync"><a href="#install-rsync" class="headerlink" title="install rsync"></a>install rsync</h3><p><code>yum install rsync</code></p><h3 id="install-shadowsocks-server"><a href="#install-shadowsocks-server" class="headerlink" title="install shadowsocks server"></a>install shadowsocks server</h3><ol><li><p>install pip package manager <code>sudo yum install python-setuptools &amp;&amp; sudo easy_install pip</code></p></li><li><p><code>pip install shadowsocks</code></p></li><li><p>配置</p><ul><li><p>创建<code>/etc/shadowsocks.json</code> <a href="https://morning.work/page/2015-12/install-shadowsocks-on-centos-7.html">详见</a></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;server_port&quot;: xxx,</span><br><span class="line">    &quot;password&quot;: &quot;xxx&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>说明：</strong></p><p>  method为加密方法，可选aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table<br>  server_port为服务监听端口<br>  password为密码，可使用密码生成工具生成一个随机密码<br>  以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。</p></li><li><p>配置自启动</p><p>  创建文件 <code>/etc/systemd/system/shadowsocks.service</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">ExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>手动启动</p><p>  <code>systemctl enable shadowsocks</code><br>  <code>systemctl start shadowsocks</code></p></li><li><p>检查服务</p><p>  <code>systemctl status shadowsocks -l</code></p></li></ul></li></ol><h3 id="安装-shadowsocks-client"><a href="#安装-shadowsocks-client" class="headerlink" title="安装 shadowsocks client"></a>安装 shadowsocks client</h3><p><a href="https://brickyang.github.io/2017/01/14/CentOS-7-%E5%AE%89%E8%A3%85-Shadowsocks-%E5%AE%A2%E6%88%B7%E7%AB%AF/">详见</a></p><h3 id="install-network-tools"><a href="#install-network-tools" class="headerlink" title="install network tools"></a>install network tools</h3><p>必须安装，否则网络命令无法执行</p><p><code>yum install net-tools</code></p><h3 id="centos-systemd-服务单元设置-system-service"><a href="#centos-systemd-服务单元设置-system-service" class="headerlink" title="centos systemd 服务单元设置 system.service"></a>centos systemd 服务单元设置 system.service</h3><p>设置为系统服务，开机自启动。</p><p><a href="http://blog.csdn.net/younger_china/article/details/52539522">详见</a></p><h3 id="安装-Let’s-Encrypt-免费证书-official"><a href="#安装-Let’s-Encrypt-免费证书-official" class="headerlink" title="安装 Let’s Encrypt 免费证书 official"></a>安装 Let’s Encrypt 免费证书 <a href="https://certbot.eff.org/lets-encrypt/centosrhel7-nginx">official</a></h3><ol><li><p><code>sudo yum -y install yum-utils</code></p></li><li><p><code>sudo yum-config-manager --enable rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional</code></p></li><li><p><code>sudo yum install certbot-nginx</code></p><p> 注意： certbot-nginx使用的是epel源，没有安装的话先安装<br> <code>yum install epel-release</code>; 如果装了还找不到包，可能是源没打开。需要配置一下<br> 打开<code>/etc/yum.repos.d/epel.repo</code> 如果<code>enabled=0</code>,说明没启用， 改成1，然后再<code>yum repolist</code>一下，发现源配置了。再做第3步的安装。</p></li><li><p>创建证书</p><p> <code>sudo certbot --nginx</code>， 根据向导输入相应的信息会生成文件及修改nginx<br> <strong>每三月换一次，不用改nginx配置</strong><br> <code>sudo certbot --nginx certonly</code></p></li></ol><h3 id="ssh-反空闲"><a href="#ssh-反空闲" class="headerlink" title="ssh 反空闲"></a>ssh 反空闲</h3><ol><li><p>配置<code>/etc/ssh/sshd_config</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">？、10分钟无动作登出</span><br><span class="line">ClientAliveInterval 60 //访问间隔，秒</span><br><span class="line">ClientAliveCountMax 10 //空闲次数</span><br></pre></td></tr></table></figure></li><li><p>重启 ssh服务</p><p> <code>service sshd restart</code></p><blockquote><p><strong>幺蛾子：</strong>　sshd command not found    </p></blockquote><p> 搬瓦工虚机把这个服务删除了。得重新装一下。  <code>sudo yum install openssh-server</code></p></li></ol><h3 id="账号管理-登录管理"><a href="#账号管理-登录管理" class="headerlink" title="账号管理|登录管理"></a>账号管理|登录管理</h3><ol><li>限制远程登录尝试密码的次数</li></ol><p><a href="http://www.cnblogs.com/zhming26/p/6186402.html">infos</a></p><h3 id="异常：字符集异常处理"><a href="#异常：字符集异常处理" class="headerlink" title="异常：字符集异常处理"></a>异常：字符集异常处理</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ocale: Cannot set LC_CTYPE to default locale: No such file or directory</span><br><span class="line">locale: Cannot set LC_ALL to default locale: No such file or directory</span><br></pre></td></tr></table></figure><p> <a href="https://www.cyberciti.biz/faq/failed-to-set-locale-defaulting-to-c-warning-message-on-centoslinux/">参考</a></p><ol><li><p><code>sudo vi /etc/profile.d/my-custom.lang.sh</code>创建一个脚本</p><p>写入内容：</p></li></ol><pre><code>## US English ##export LANG=en_US.UTF-8export LANGUAGE=en_US.UTF-8export LC_COLLATE=Cexport LC_CTYPE=en_US.UTF-8</code></pre><ol start="2"><li>执行 <code>source my=custom.lang.sh</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;资料&quot;&gt;&lt;a href=&quot;#资料&quot; class=&quot;headerlink&quot; title=&quot;资料&quot;&gt;&lt;/a&gt;资料&lt;/h4&gt;&lt;p&gt;ip命令&lt;a href=&quot;http://blog.csdn.net/hunyxv/article/details/51900482&quot;&gt;htt
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="CentOS" scheme="1824437.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Vue与React比较</title>
    <link href="1824437.github.io/frame/%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/%E6%A1%86%E6%9E%B6%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>1824437.github.io/frame/框架的比较/框架的比较/</id>
    <published>2019-10-29T06:12:32.338Z</published>
    <updated>2019-10-29T06:15:21.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架比较"><a href="#框架比较" class="headerlink" title="框架比较"></a>框架比较</h1><ul><li><p>Angular</p><ul><li>MVW框架</li><li>MIT license</li></ul></li><li><p>Vue</p><ul><li>MVVM框架</li><li>MIT license</li></ul></li><li><p>React</p></li></ul><h2 id="Vue-vs-React"><a href="#Vue-vs-React" class="headerlink" title="Vue vs React"></a>Vue vs React</h2><h3 id="共通点"><a href="#共通点" class="headerlink" title="共通点"></a>共通点</h3><ul><li><p>所有的state都必须预先定义。否则变化不跟踪。</p><ul><li><p>这点对于需要异步数据初始化状态来讲，有两种初始化的办法</p><ol><li><p>异步请求数据与初始化实例同步运行,在实例的mounted里添加then方法来变更空白数据。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let asyncData = fetch(...);</span><br><span class="line">new Vue(&#123;</span><br><span class="line">store,</span><br><span class="line">mounted()&#123;</span><br><span class="line">asyncData.then(</span><br><span class="line">data =&gt; &#123;</span><br><span class="line">this.$store.commit(&quot;***&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line">).catch();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 这种方法被渲染一次空白，然后再更新一遍所有的数据。</p></li><li><p>先拿到fetch的数据后开始初始化实例。</p><p>对速度而言，第一种首选。</p></li></ol></li></ul></li></ul><a id="more"></a><blockquote><p>关于props</p></blockquote><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><em>Vue</em></h4><blockquote><p>vue 的this.$data,this.$props通过初始化后，可以通过this[dataName|propName]访问。</p></blockquote><ol><li>props是用来传递数据的，方法通过@custom event传递</li><li>属性改变，立即会改变所有使用此属性的视图。但是基础属性值必须通过this.$emit的方式修改。</li><li>实现了双绑, $props={parcel.x} v-model={parcel.x}, 简单实现动态修改属性parcel.x，任何值用此属性的视图都会改变。（对非基础值而言）</li><li>插槽功能： 可以使用slot功能 多插用具名slot。</li><li>动态组件: “:is”特性解决。<ul><li>将各个需要引用的动态组件require到components字段。key会作为:is的值。</li><li>在模版中使用<code>&lt;component v-bind:is=&quot;currentView&quot;&gt;&lt;/component&gt;</code></li></ul></li><li>props的动态使用<ul><li>加逻辑使用时可以在computed里定义方法，然后直接使用方法名。</li></ul></li><li>可以通过set设置数组的值。</li><li>支持mixin对象。对组件做一些合并。</li><li>extends 继承</li><li>v-pre标记，vue不会关心这个标记下的dom.</li></ol><h4 id="React"><a href="#React" class="headerlink" title="React"></a><em>React</em></h4><ol><li>任何要传递的资源都通过props，包括数据，函数</li><li>不能直接通过修改数据属性的值来获得视图修改，而是修改state，再将state通过属性往下传。</li><li>无双绑概念,通过属性传递方法来个改。</li><li>插槽功能：使用props.children实现; 多插用自定义属性。</li><li>动态组件： <ul><li>引入各组件</li><li>在render之间先判断使用哪个组件并赋值给以大写字母开头的变量，然后直接在return中直接引用。</li></ul></li><li>props的动态使用<ul><li>在类中直接创建方法，使用: {a()}</li></ul></li><li>改完后，通过setState重新赋值一下。</li><li>不支持mixin</li><li>高阶组件，能实现继承及vue的自定义属性</li><li>非监控dom, 弄一个空dom，不引用任何属性，react不会关心这个dom的存在。</li></ol><p>-</p><blockquote><p>一个input.text ,受属性x的影响获得值x,也受自身变化获得自身的值y。<br>如何设计动态修改state.m ?</p></blockquote><h4 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a><em>Vue</em></h4><ol><li>v-model=y</li><li>methods : {changeY(){}}</li></ol><h4 id="React-1"><a href="#React-1" class="headerlink" title="React"></a><em>React</em></h4><p>-</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;框架比较&quot;&gt;&lt;a href=&quot;#框架比较&quot; class=&quot;headerlink&quot; title=&quot;框架比较&quot;&gt;&lt;/a&gt;框架比较&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Angular&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVW框架&lt;/li&gt;
&lt;li&gt;MIT license&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Vue&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVVM框架&lt;/li&gt;
&lt;li&gt;MIT license&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;React&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Vue-vs-React&quot;&gt;&lt;a href=&quot;#Vue-vs-React&quot; class=&quot;headerlink&quot; title=&quot;Vue vs React&quot;&gt;&lt;/a&gt;Vue vs React&lt;/h2&gt;&lt;h3 id=&quot;共通点&quot;&gt;&lt;a href=&quot;#共通点&quot; class=&quot;headerlink&quot; title=&quot;共通点&quot;&gt;&lt;/a&gt;共通点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所有的state都必须预先定义。否则变化不跟踪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这点对于需要异步数据初始化状态来讲，有两种初始化的办法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;异步请求数据与初始化实例同步运行,在实例的mounted里添加then方法来变更空白数据。&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let asyncData = fetch(...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	store,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	mounted()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		asyncData.then(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			data =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				this.$store.commit(&amp;quot;***&amp;quot;, data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		).catch();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 这种方法被渲染一次空白，然后再更新一遍所有的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;先拿到fetch的数据后开始初始化实例。&lt;/p&gt;
&lt;p&gt;对速度而言，第一种首选。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="frame" scheme="1824437.github.io/categories/frame/"/>
    
    
      <category term="Vue" scheme="1824437.github.io/tags/Vue/"/>
    
      <category term="React" scheme="1824437.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Jade, Node.js Template Engine</title>
    <link href="1824437.github.io/popular/jade/jade/"/>
    <id>1824437.github.io/popular/jade/jade/</id>
    <published>2019-10-28T09:48:18.403Z</published>
    <updated>2019-10-28T09:52:38.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一款server端-Node-js-模版。"><a href="#一款server端-Node-js-模版。" class="headerlink" title="一款server端(Node.js)模版。"></a>一款server端(Node.js)模版。</h2><p><a href="http://jade-lang.com/">official</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一款server端-Node-js-模版。&quot;&gt;&lt;a href=&quot;#一款server端-Node-js-模版。&quot; class=&quot;headerlink&quot; title=&quot;一款server端(Node.js)模版。&quot;&gt;&lt;/a&gt;一款server端(Node.js)模版。&lt;/
      
    
    </summary>
    
    
      <category term="popular" scheme="1824437.github.io/categories/popular/"/>
    
    
      <category term="tmeplate" scheme="1824437.github.io/tags/tmeplate/"/>
    
      <category term="jade" scheme="1824437.github.io/tags/jade/"/>
    
  </entry>
  
  <entry>
    <title>FED岗位通常需要参考的标准，规范</title>
    <link href="1824437.github.io/standard/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86/%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86/"/>
    <id>1824437.github.io/standard/常用标准/常用标准/</id>
    <published>2019-10-28T02:29:26.521Z</published>
    <updated>2019-10-28T03:02:02.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><ol><li>W3C</li><li>WHATWG</li><li>ECMA</li></ol><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;组织&quot;&gt;&lt;a href=&quot;#组织&quot; class=&quot;headerlink&quot; title=&quot;组织&quot;&gt;&lt;/a&gt;组织&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;W3C&lt;/li&gt;
&lt;li&gt;WHATWG&lt;/li&gt;
&lt;li&gt;ECMA&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;标准&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="standard" scheme="1824437.github.io/categories/standard/"/>
    
    
      <category term="W3C" scheme="1824437.github.io/tags/W3C/"/>
    
      <category term="ECMA" scheme="1824437.github.io/tags/ECMA/"/>
    
      <category term="WHATWG" scheme="1824437.github.io/tags/WHATWG/"/>
    
  </entry>
  
  <entry>
    <title>web/css3/css3</title>
    <link href="1824437.github.io/web/css3/css3/"/>
    <id>1824437.github.io/web/css3/css3/</id>
    <published>2019-10-27T10:47:26.133Z</published>
    <updated>2019-11-01T02:56:34.637Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用配置文件格式</title>
    <link href="1824437.github.io/os/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>1824437.github.io/os/常用配置文件/常用配置文件格式/</id>
    <published>2019-10-27T08:05:41.060Z</published>
    <updated>2019-10-29T06:15:18.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ini"><a href="#1-ini" class="headerlink" title="1. ini"></a>1. ini</h2><h2 id="2-properties-java下的配置文件"><a href="#2-properties-java下的配置文件" class="headerlink" title="2. properties java下的配置文件"></a>2. properties java下的配置文件</h2><p><strong>格式</strong></p><ol><li><p>注释</p><p> 以!或#开头的行将作为comment注释行 </p></li><li><p>一行一个键值对, 键值对分隔符[=, :, 空格, tab制表符]</p></li><li><p>忽略多余的空格及tab制表符</p></li><li><p>=, :转义字符=和:字符</p></li><li><p>跨行书写时在尾部增加转义符\</p></li><li><p>无值时视为空格</p></li><li><p>非ASCII字符需要使用Unicode转义序列</p></li></ol><p>\u****</p><a id="more"></a><h2 id="3-json"><a href="#3-json" class="headerlink" title="3. json"></a>3. json</h2><h2 id="4-xml"><a href="#4-xml" class="headerlink" title="4. xml"></a>4. xml</h2><h2 id="5-yaml"><a href="#5-yaml" class="headerlink" title="5. yaml"></a>5. yaml</h2><p><a href="http://www.yaml.org/">http://www.yaml.org/</a></p><h2 id="6-plist"><a href="#6-plist" class="headerlink" title="6.plist"></a>6.plist</h2><h2 id="7-HOCON"><a href="#7-HOCON" class="headerlink" title="7.HOCON"></a>7.HOCON</h2><h2 id="8-toml"><a href="#8-toml" class="headerlink" title="8.toml"></a>8.toml</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-ini&quot;&gt;&lt;a href=&quot;#1-ini&quot; class=&quot;headerlink&quot; title=&quot;1. ini&quot;&gt;&lt;/a&gt;1. ini&lt;/h2&gt;&lt;h2 id=&quot;2-properties-java下的配置文件&quot;&gt;&lt;a href=&quot;#2-properties-java下的配置文件&quot; class=&quot;headerlink&quot; title=&quot;2. properties java下的配置文件&quot;&gt;&lt;/a&gt;2. properties java下的配置文件&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;格式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注释&lt;/p&gt;
&lt;p&gt; 以!或#开头的行将作为comment注释行 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一行一个键值对, 键值对分隔符[=, :, 空格, tab制表符]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;忽略多余的空格及tab制表符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;=, :转义字符=和:字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;跨行书写时在尾部增加转义符\&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无值时视为空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非ASCII字符需要使用Unicode转义序列&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;\u****&lt;/p&gt;
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="ini" scheme="1824437.github.io/tags/ini/"/>
    
      <category term="json" scheme="1824437.github.io/tags/json/"/>
    
      <category term="xml" scheme="1824437.github.io/tags/xml/"/>
    
      <category term="yaml" scheme="1824437.github.io/tags/yaml/"/>
    
      <category term="plist" scheme="1824437.github.io/tags/plist/"/>
    
      <category term="hocon" scheme="1824437.github.io/tags/hocon/"/>
    
      <category term="toml" scheme="1824437.github.io/tags/toml/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="1824437.github.io/popular/webpack/webpack/"/>
    <id>1824437.github.io/popular/webpack/webpack/</id>
    <published>2019-10-27T08:01:38.572Z</published>
    <updated>2019-10-27T08:08:44.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><a href="https://doc.webpack-china.org/">中文文档</a><br><strong>待读</strong> happypack 原理 <a href="https://yq.aliyun.com/articles/67269">https://yq.aliyun.com/articles/67269</a></p><h2 id="资源处理"><a href="#资源处理" class="headerlink" title="资源处理"></a>资源处理</h2><h3 id="紧密耦合式"><a href="#紧密耦合式" class="headerlink" title="紧密耦合式"></a>紧密耦合式</h3><ol><li><p>css处理方案</p><h4 id="直接通过JS内嵌到文档的head中"><a href="#直接通过JS内嵌到文档的head中" class="headerlink" title="直接通过JS内嵌到文档的head中"></a>直接通过JS内嵌到文档的head中</h4><ol><li><p>安装使用loader: style-loader,css-loader。</p></li><li><p>在js中<code>import &#39;styles.css&#39;</code>即可。bundle时会通过JS写入文档的head中。</p></li></ol></li><li><p>图片、字体处理方案</p><h4 id="js引入"><a href="#js引入" class="headerlink" title="js引入"></a>js引入</h4><ol><li><p>安装使用file-loader</p></li><li><p>在js中 `import img from ‘./assets/images/icon.png’，然后new Image一个对象指向src。bundle后会把文件复制到dist中。</p><p>css中的图片，css-loader也会做同样的事情。无论图片在哪里使用，都会生成一个唯一图片供所有地方引用。</p><p>css中的字体，仍然可以使用file-loader来处理。</p></li></ol></li></ol><ol start="3"><li><p>CSV、TSV、XML文件处理方案</p><h4 id="csv-tsv使用csv-loader"><a href="#csv-tsv使用csv-loader" class="headerlink" title="csv,tsv使用csv-loader"></a>csv,tsv使用csv-loader</h4><h4 id="xml使用xml-loader"><a href="#xml使用xml-loader" class="headerlink" title="xml使用xml-loader"></a>xml使用xml-loader</h4></li><li><p>scss处理</p></li></ol><h2 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h2><ol><li>利用html-webpack-plugin来生成index.html文件</li></ol><h2 id="动态热替换"><a href="#动态热替换" class="headerlink" title="动态热替换"></a>动态热替换</h2><p>通过webpack-dev-server实现。<br>如果出现编译异常，可能是包的问题。先看webpack-dev-server的package.json。看webpack与webpack-dev-server的版本号对不对。如果安装的对，如果再有问题，可以参照下面的已装包，看有没有缺失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;webpack-cli&quot;: &quot;^3.3.2&quot;,</span><br><span class="line">    &quot;webpack-dev-middleware&quot;: &quot;^3.6.2&quot;,</span><br><span class="line">    &quot;webpack-dev-server&quot;: &quot;^3.3.1&quot;,</span><br><span class="line">    &quot;webpack-hot-middleware&quot;: &quot;^2.24.4&quot;</span><br></pre></td></tr></table></figure><h2 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h2><p><a href="https://juejin.im/post/5b99b9cd6fb9a05cff32007a">学习链接</a><br><a href="https://segmentfault.com/a/1190000013476837">2</a></p><h2 id="各字段详解"><a href="#各字段详解" class="headerlink" title="各字段详解"></a>各字段详解</h2><p><strong>output.path,output.publicPath,devServer.publicPath,devServer.contentBase</strong></p><ol><li><p>output.path, 指定打包输出的目录。</p><p> 将源代码打生产包时，生成在哪个文件夹下。所有的包，包含js,css,image,svg,font，及入口文件index.html。</p></li><li><p>output.publicPath</p><p> 这个配置是将代码内所有的资源引用路径都加上一个前缀。默认的publicPath,输出的index.html对js引用是<code>/app.*.js</code>,如果加上<code>outpub.publicPath = &#39;/abc/&#39;</code>,那么输出的index.html对js的引用会变成<code>/abc/app.*.js</code>.不仅是index.html,所有的所有包的引用路径者会这样变。</p><p> 注：<code>output.path: &#39;dist/abc&#39;与将publicPath设置为&#39;/abc/&#39;是不同的</code>。<code>output.path: &#39;dist/abc&#39;</code>只会将包输出到dist/abc目录下，不会改变包的引用。</p></li></ol><ol start="3"><li><p>devServer.publicPath</p><p> 控制在开发环境下给资源引用路径加上前缀。如果没有配置这个选项，则使用output.publicPath。</p></li><li><p>devServer.contentBase</p><p> 在开发环境下指定静态文件(index.html)的位置，会读取指定的index.html而不是HtmlWebpackPlugin生成的。对生产包没有影响。<br> 这个必须配合devServer.publicPath</p></li></ol><p><strong><a href="https://www.webpackjs.com/configuration/externals/#externals">externals</a></strong></p><blockquote><p>需要以require或import的方式使用，但已通过&lt;script&gt;链接了公共资源; 打包时需要忽略掉require的源码，这种情况下需要使用。</p></blockquote><ul><li>string<br><code>externals:{key: value}</code><br>key 表示在js中引用的变<br>value 表示CDN抛出的全局变量。如</li></ul><p><code>externals:{    &#39;$Vue&#39;: &#39;Vue&#39;}</code>, js中<code>import Vue from &#39;$Vue&#39;</code></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>配置<code>rules: [{   test: require.resolve(&#39;./src/index.js&#39;),   use: &#39;imports-loader?this=&gt;window&#39; }]</code>后，index.js文件内有<code>import numRef from &#39;./ref.json&#39;</code>引入json报错<code>ERROR in ./src/index.js 4:0Module parse failed: &#39;import&#39; and &#39;export&#39; may only appear at the top level (4:0)You may need an appropriate loader to handle this file type.</code></li></ol><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR in chunk another [entry]</span><br><span class="line">[name].[chunkhash].js</span><br><span class="line">Cannot use [chunkhash] or [contenthash] for chunk in &apos;[name].[chunkhash].js&apos; (use [hash] instead)</span><br></pre></td></tr></table></figure><p>原因：热更新(HMR)不能和[chunkhash]同时使用。</p><ol start="3"><li><p>打包时，hash频繁变动? </p><p> 生产环境添加Plugins: new webpack.HashedModuleIdsPlugin()。<br> <strong>但是，当入口文件增加时，hash仍然会变化，怎么解？</strong></p><ol><li>公共包可以解决，将chunkFilename的名字不加上hash。</li></ol></li><li><p>node-sass安装不成功。</p><p> 如果遇到错误 error: xxxx node-sass: Command failed</p></li></ol><p>将 sass-binary-site 添加至 config 中</p><p><code>yarn config set sass-binary-site https://npm.taobao.org/mirrors/node-sass</code></p><p><code>npm config set sass-binary-site https://npm.taobao.org/mirrors/node-sass</code></p><p>指定 node-sass 从 npm 的淘宝源中下载。</p><ol start="5"><li><p>vue中的css被单独打包了，如果不想单独打包，怎么办？</p><p> 很简单，如果不需要单独打包，就别写在vue文件中。写在vue文件中，就会被单独打包。</p></li></ol><p>##应用</p><h3 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a><a href="https://www.webpackjs.com/guides/hot-module-replacement/#%E5%90%AF%E7%94%A8-hmr">模块热替换</a></h3><p><strong>不是配置webpack HMR后，就可以任意热替换所有的模块</strong>。<br>实际上是通过module.hot.accept来监控某个模块，如a.js, 然后运行a.js内某个方法。例如，修改之前a()是console.log(1);现在更改了a.js的a方法,改成了console.log(2)。热替换就是在module.hot.accept的回调里运行a()能保证是新的，也就是输出2。如果页面有绑定事件执行a()仍然是输出1。<br>所以不光是webpack.config配置，还是要在js中配合使用。</p><h3 id="css中使用alias"><a href="#css中使用alias" class="headerlink" title="css中使用alias"></a>css中使用alias</h3><p>只需要在开头加<code>~</code></p><h3 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h3><ol><li><p>分包配置 <a href="https://juejin.im/post/5b99b9cd6fb9a05cff32007a">资料1</a> <a href="https://juejin.im/post/5af1677c6fb9a07ab508dabb">资料2</a> <a href="https://www.cnblogs.com/dashnowords/p/9545482.html">资料3</a> <a href="https://segmentfault.com/a/1190000010317802">资料4</a></p><blockquote><p>之前个人想法，是不是输出一个专门的入口包文件。事实上很蠢。因为包文件没有公布全局变量。</p></blockquote><p> 使用<code>optimization.splitChunks</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     chunks: &apos;initial&apos;,</span><br><span class="line">     cacheGroups: &#123;</span><br><span class="line">       vue: &#123;</span><br><span class="line">         name: &apos;vue-2.6.10&apos;,</span><br><span class="line">         test: /vue|vuex|vue-router/</span><br><span class="line">       &#125;,</span><br><span class="line">       react: &#123;</span><br><span class="line">         name: &apos;react-16.8.6&apos;,</span><br><span class="line">         test: /react|react-dom/</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 最麻烦的场景： 如有2个包jquery,lodash。在入口a.js中引入了其中一个jquery。在异步b.js中引了这2个。如果</p></li></ol><h3 id="webpack-vue配置"><a href="#webpack-vue配置" class="headerlink" title="webpack - vue配置"></a>webpack - vue配置</h3><ol><li><p>语法检查 eslint-plugin-vue</p><ol><li>安装 eslint-plugin-vue</li><li>eslintrc.js 增加extends: ‘plugin:vue/recommended’</li></ol></li><li><p>预处理</p><ol><li><p>安装 vue-loader, 提示安装vue-template-compiler</p></li><li><p>在webpack配置中增加plugins.</p><p> <code>const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);</code></p><p> <code>plugins: [new VueLoaderPlugin()]</code></p></li></ol></li></ol><ol start="3"><li><p>环境场景1: Vue在生产环境中使用CDN,开发环境中使用完整包</p><ol><li><p>dev.config:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">   alias: &#123;</span><br><span class="line">     $Vue: &apos;vue&apos;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> 为什么要配置webpack.dev.config; 完全可以不用配置也能正常运行。但是打包的时候在app.js里面也会打进vue的源码。只有在dev使用alias,在prod使用externals，打包的时候不会打包vue源。这种原理同样适合所以的包。</p></li><li><p>prod.config:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">externals:&#123;</span><br><span class="line">  &apos;$Vue&apos;: &apos;Vue&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>html</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://library.theme.com/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://library.theme.com/vue-router/dist/vue-router.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://library.theme.com/vuex/dist/vuex.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>js</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;$Vue&apos;;</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">  Vue.use(VueRouter);</span><br><span class="line">  Vue.use(Vuex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 并不需要引用vuex和vuerouter,开发环境和生产环境都用cdn就可以了。</p></li></ol></li><li><p>环境场景2：将vue及插件单独打包，不使用CDN。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">   splitChunks: &#123;</span><br><span class="line">     chunks: &apos;initial&apos;,</span><br><span class="line">     cacheGroups: &#123;</span><br><span class="line">       vue: &#123;</span><br><span class="line">         name: &apos;vue-2.6.10&apos;,</span><br><span class="line">         test: /vue|vuex|vue-router/</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="将css打包成文件输出"><a href="#将css打包成文件输出" class="headerlink" title="将css打包成文件输出"></a>将css打包成文件输出</h3><p>使用<a href="https://www.npmjs.com/package/mini-css-extract-plugin">mini-css-extract-plugin</a></p><h3 id="css预处理"><a href="#css预处理" class="headerlink" title="css预处理"></a>css预处理</h3><ol><li>安装</li></ol><h3 id="js支持es6"><a href="#js支持es6" class="headerlink" title="js支持es6"></a>js支持es6</h3><h3 id="es7装饰器插件"><a href="#es7装饰器插件" class="headerlink" title="es7装饰器插件"></a>es7装饰器插件</h3><ol><li><p><code>yarn add @babel/plugin-proposal-decorators -D</code></p></li><li><p><code>&quot;plugins&quot;: [ [&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }],]</code></p></li></ol><p>注意: 要放在plugin-proposal-class-properties前面。</p><pre><code>[&apos;@babel/plugin-proposal-decorators&apos;, { &apos;legacy&apos;: true }],&apos;@babel/plugin-proposal-class-properties&apos;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;link&quot;&gt;&lt;a href=&quot;#link&quot; class=&quot;headerlink&quot; title=&quot;link&quot;&gt;&lt;/a&gt;link&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://doc.webpack-china.org/&quot;&gt;中文文档&lt;/a&gt;&lt;br&gt;&lt;strong&gt;待
      
    
    </summary>
    
    
      <category term="popular" scheme="1824437.github.io/categories/popular/"/>
    
    
      <category term="webpack" scheme="1824437.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>babel</title>
    <link href="1824437.github.io/popular/babel/babel/"/>
    <id>1824437.github.io/popular/babel/babel/</id>
    <published>2019-10-27T08:01:23.622Z</published>
    <updated>2019-10-27T08:09:10.852Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="popular" scheme="1824437.github.io/categories/popular/"/>
    
    
      <category term="babel" scheme="1824437.github.io/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>eslint</title>
    <link href="1824437.github.io/popular/eslint/eslint/"/>
    <id>1824437.github.io/popular/eslint/eslint/</id>
    <published>2019-10-27T08:01:06.006Z</published>
    <updated>2019-10-27T08:09:01.353Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="popular" scheme="1824437.github.io/categories/popular/"/>
    
    
      <category term="eslint" scheme="1824437.github.io/tags/eslint/"/>
    
  </entry>
  
  <entry>
    <title>SASS</title>
    <link href="1824437.github.io/web/sass/sass/"/>
    <id>1824437.github.io/web/sass/sass/</id>
    <published>2019-10-27T08:00:39.373Z</published>
    <updated>2019-10-27T08:11:35.340Z</updated>
    
    <content type="html"><![CDATA[<p>语法大全 <a href="https://www.sass.hk/docs/">https://www.sass.hk/docs/</a></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>一个变量不存在时，引用该变量的样式声明会被删除。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li><p>嵌套</p><ul><li>声明嵌套</li><li>属性嵌套</li><li>父选择器 &amp;</li></ul></li><li><p>占位符 %</p></li><li><p>注释/* */, //, 其中 //注释在编译时删除</p></li><li><p>变量 $</p><ul><li><p>局部变量变全局变量添加!global声明<code>$width: 12px !global</code>  </p></li><li><p>特殊变量, 一个复合值如font:”12px/1.5”;需要#{vername}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$var1:12px;$var2:1.5;$var3=.header; </span><br><span class="line">font:#&#123;$var1&#125;/#&#123;$var2&#125; </span><br><span class="line">.main #&#123;$var3&#125;:after&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义变量值为多个值时，如字体，应该用#{}</p><p><code>$ff: #{&quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif, st}</code></p></li><li><p>数组，map</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">$px2</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line"><span class="variable">$px3</span>: <span class="number">10px</span> <span class="number">20px</span>, <span class="number">30px</span> <span class="number">40px</span>; <span class="comment">//分组</span></span><br><span class="line"><span class="variable">$px4</span>: (<span class="number">10px</span> <span class="number">20px</span>) (<span class="number">30px</span> <span class="number">40px</span>); <span class="comment">//分组</span></span><br><span class="line"><span class="variable">$util</span>: (padding:<span class="number">20px</span>,margin:<span class="number">30px</span>); <span class="comment">//对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>运算</p><ul><li>数字运算符 +, -, *, /,%</li><li>关系运算符 &lt;, &gt;, &lt;=, &gt;=</li><li>相等 == !=</li><li>插值#{}<br>  <code>content:&quot;a#{1+3}c&quot;</code></li><li>布尔运算 and, or, not  </li></ul></li></ol><ol start="6"><li><p>函数</p><p> 所有函数列表<a href="http://sass-lang.com/documentation/Sass/Script/Functions.html">http://sass-lang.com/documentation/Sass/Script/Functions.html</a></p><ul><li><p>常用</p><ul><li>ie-hex-str()</li><li>nth()</li><li>map-get()</li></ul></li><li><p>自定义函数 @function</p></li></ul></li><li><p>默认值 !default 未定义的变量取带默认值的值，否则不取默认值</p></li><li><p>@import 导入sass文件</p><ul><li><p>与CSS原生的@import的区分：当发生以下情况不会使用sass解析</p><ol><li><p>文件扩展名是.css</p></li><li><p>文件名以协义开头</p></li><li><p>使用url()包裹文件</p></li><li><p>带有媒体查询的<br><code>@import url(&quot;//qunarzz.com/css/reset.css&quot;) screen</code></p></li><li><p>以上情况除外即使不在扩展名也会查找sass文件，找到即导入。 </p></li><li><p>当scss文件不想被处理时，在文件改名，前加下划线即可。<br> <code>_a.scss; @import a.scss</code></p></li><li><p>不可以在混合指令mixin或控制指令(if,for…)中使用导入。</p></li></ol></li></ul></li><li><p>@media 支持媒体查询，支持动态变量插入</p></li><li><p>@extend 样式继承<code>.a{} .b{@extend .a;}</code></p><ul><li><p>样子继承会无限继承底层样式及超类自身继承的样式。所以在.a下定义的其它样式都会继承，所以.a @extend的样式也会被继承。</p></li><li><p>可以继承多个超类，如发生冲突，后定义的会覆盖先定义的。</p></li><li><p>使用%占位继承,%定义部分单独使用不会生效</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#a h1%level&#123;color:red&#125;;</span><br><span class="line">//a h1不会有color:red样式</span><br><span class="line">.l3 &#123;@extend %level&#125;</span><br><span class="line">// #a h1.l3 &#123;color:red;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在指令中扩展时，只能扩展指令内部的样式，外部样式不能。</p></li></ul></li><li><p>控制指令 @if @else if @else @for @each @while</p><p><code>@if &lt;condition&gt; {} @else {}</code></p></li></ol><ol start="12"><li><p>混合指令 mixin</p><ul><li><p>@include来应用混合</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> fonts &#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;@<span class="keyword">include</span> fonts&#125;</span><br></pre></td></tr></table></figure></li><li><p>加入参数</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数名格式与定义变量是一样的</span></span><br><span class="line">@<span class="keyword">mixin</span> fonts (<span class="variable">$color</span>, <span class="variable">$fontsize</span>) &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$color</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="variable">$fontsize</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;@<span class="keyword">include</span> fonts&#125;</span><br></pre></td></tr></table></figure></li><li><p>不定参数    (和JS解构赋值及剩余参数差不多）</p></li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> fonts (<span class="variable">$args</span>...)&#123;</span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="variable">$args</span></span><br><span class="line">&#125;</span><br><span class="line">.a&#123;@include fonts(<span class="number">9px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">4px</span> <span class="number">#555</span>)&#125;</span><br><span class="line">//或者</span><br><span class="line"><span class="variable">$xxx</span> = <span class="number">9px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">4px</span>;</span><br><span class="line"><span class="selector-class">.a</span>&#123;@<span class="keyword">include</span> fonts(<span class="variable">$xxx</span>...)</span><br></pre></td></tr></table></figure></li></ol><p>-</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><p>global-variable-exists</p><p>  检查一个全局变量(<code>! global</code>)是否存在,变量名引用不需要$<br>  <code>@if global-variable-exists(){}</code></p></li></ul><h2 id="变量-map变量-list变量-特殊变量"><a href="#变量-map变量-list变量-特殊变量" class="headerlink" title="变量; map变量; list变量; 特殊变量;"></a>变量; map变量; list变量; 特殊变量;</h2><p><strong>定义</strong>  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$px</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$px2</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line"><span class="variable">$px3</span>: <span class="number">10px</span> <span class="number">20px</span>, <span class="number">30px</span> <span class="number">40px</span>;</span><br><span class="line"><span class="variable">$px4</span>: (<span class="number">10px</span> <span class="number">20px</span>), (<span class="number">30px</span> <span class="number">40px</span>);</span><br><span class="line"><span class="variable">$util</span>: (padding:<span class="number">20px</span>,margin:<span class="number">30px</span>);</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$px1</span>; <span class="comment">// 20px;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.b</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: nth(<span class="variable">$px2</span>,<span class="number">3</span>); <span class="comment">// 30px;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.c</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: nth(<span class="variable">$px3</span>,<span class="number">1</span>); <span class="comment">// 10px 20px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.d</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: nth(<span class="variable">$px4</span>,<span class="number">2</span>); <span class="comment">//30px 40px</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.e</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: map-get(<span class="variable">$util</span>,padding); <span class="comment">// 20px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="占位符号"><a href="#占位符号" class="headerlink" title="占位符号"></a>占位符号</h2><p><strong>定义</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-tag">base</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">10px</span>;<span class="attribute">padding</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line">@<span class="keyword">extend</span> %base; <span class="comment">//margin:10px;padding:20px;</span></span><br><span class="line"><span class="attribute">color</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p><strong>使用</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span>&#123;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">10px</span>;</span><br><span class="line">&amp;:hover&#123; <span class="comment">// .a:hover</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="selector-class">.title</span>&#123; <span class="comment">// .a .title</span></span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&amp;_bd&#123; <span class="comment">// .a .title_bd</span></span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">border</span>:&#123;</span><br><span class="line">style: solid;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line"><span class="attribute">left</span>: &#123; // border-left</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;语法大全 &lt;a href=&quot;https://www.sass.hk/docs/&quot;&gt;https://www.sass.hk/docs/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则
      
    
    </summary>
    
    
      <category term="web" scheme="1824437.github.io/categories/web/"/>
    
    
      <category term="css" scheme="1824437.github.io/tags/css/"/>
    
      <category term="sass" scheme="1824437.github.io/tags/sass/"/>
    
  </entry>
  
  <entry>
    <title>字符集及编码</title>
    <link href="1824437.github.io/web/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%8F%8A%E7%BC%96%E7%A0%81/%E5%AD%97%E7%AC%A6%E9%9B%86%E5%8F%8A%E7%BC%96%E7%A0%81/"/>
    <id>1824437.github.io/web/字符集及编码/字符集及编码/</id>
    <published>2019-10-27T07:48:08.782Z</published>
    <updated>2019-10-28T04:24:30.934Z</updated>
    
    <content type="html"><![CDATA[<h3 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h3><p>后端在往页面上（如js变量,textarea值)串化的json字符串时，一定要再串化一下；否则串化在字串在浏览器处理过</p><p>-</p><ol><li><h3 id="encodeURI，encodeURIComponent两个方法的区别？"><a href="#encodeURI，encodeURIComponent两个方法的区别？" class="headerlink" title="encodeURI，encodeURIComponent两个方法的区别？"></a>encodeURI，encodeURIComponent两个方法的区别？</h3><blockquote><p>这两个方法是将字符转换是UTF-8编码；以%开头。<br>encodeURI为要的作用是对url中的<strong>不利于传递的字符进行编码</strong><br> 像中文字符按照《RFC 1738》规定，汉字必须编码；但怎么编，自行决定。<br> 所以，页面的字符编码与服务器端解码不一样，那么就会得到乱码。<br> encodeURI就是固定使用utf-8的对字串进行编码，但排除了一些字符。</p></blockquote><blockquote><p>encodeURIComponent的作用是如果一个URL里面的<strong>某个参数也是一个url</strong><br>这样的话，这个URL就有了二义性，如下：<br>“<a href="http://www.b.com?a=100&amp;b=www.c.com?y=100&amp;z=200&quot;">http://www.b.com?a=100&amp;b=www.c.com?y=100&amp;z=200&quot;</a><br>所以，当一个url的参数包括另一个url的话，这个作为参数值的url必须encodeURIComponent编码。</p></blockquote></li></ol><a id="more"></a><ol start="2"><li><h3 id="字符集-ASCII-GB-18030-2005-Unicode-latin-1"><a href="#字符集-ASCII-GB-18030-2005-Unicode-latin-1" class="headerlink" title="字符集 ASCII, GB 18030-2005, Unicode, latin-1"></a>字符集 ASCII, GB 18030-2005, Unicode, latin-1</h3><ul><li><p>ASCII 共128个字符，7bit二进制表示，code point </p></li><li><p>latin-1 共256个字符，8位表示，在ascii基础上增加了</p></li><li><p>GB 18030-2005, 中国搞的一套最新字符集，之前有过几个版版像GB2312-80<br>  unicode中的汉字编码与GB 18030-2005是兼容的，或者说是按照中国的标准搬到unicode的码点上的。</p></li><li><p><strong>Unicode，最全的字符集，及无限的扩展</strong><br>  <a href="http://thoughtfly.iteye.com/blog/977495">0平面区间含义</a></p><ul><li><p>编号规则<br>用16进制编号从0-10ffff，共1114111个码位，能代表1114111个字符，把这些码位分成了17个平面； 或者说每次增加就定义一个平面，共定义了17个平面，容纳1114111个字符。</p><table><thead><tr><th>平面</th><th>码位段</th><th>名称</th><th>英文名称</th></tr></thead><tbody><tr><td>0</td><td>U+0000 - U+FFFF</td><td>基本多文种平面</td><td>Basic Multilingual Plane</td></tr><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td></tr><tr><td>4-13</td><td></td><td>未使用</td><td></td></tr><tr><td>14</td><td></td><td>特别用途补充平面</td><td>supplementary special-purpose plane</td></tr><tr><td>15</td><td></td><td>保留作为私人使用区</td><td>private use area</td></tr><tr><td>16</td><td></td><td>保留作为私人使用区</td><td></td></tr></tbody></table></li></ul></li></ul></li></ol><ol start="3"><li><p>编码方案    </p><ul><li><p>UCS2 与 UCS4</p><p>  UCS2 被整合到了<strong>UTF-16</strong>里面。<br>  UCS2 就是用2个字节来代表码点，两个字节意味着：<br>  二进制值00000000 00000000 - 11111111 11111111<br>  十六进制值 0x0000 - 0xffff<br>  十进制值是 0 - 65535<br>  对应就是unicode字符集的0平面。</p><p>  UCS4 被整合到了<strong>UTF-32</strong>里面。用4个字节代表码点。<br>  二进制 4个8位，太长不写了。<br>  十六进制 0x 00 00 00 00 - 0x FF FF FF FF<br>  十进制 0-4294967295<br>  能代表unicode现有的17个平面及未来扩展。 </p></li><li><p>UTF-32<br>  用位来表示一个字符，和unicode一一对应<br>  最大的二进制与16进制<br>  11111111 11111111 11111111 11111111 -&gt; ff ff ff ff<br>  缺点：<br>  代表字母a,ascii码的16进制为 61，而utf-32则是00 00 00 61,存放空间多了三位。</p></li><li><h4 id="UTF-8-可变长的编码方案"><a href="#UTF-8-可变长的编码方案" class="headerlink" title="UTF-8 可变长的编码方案"></a>UTF-8 可变长的编码方案</h4><ul><li>unicode转码方案</li></ul><table><thead><tr><th>unicode码点范围</th><th>转换字节数</th><th>转换规则</th><th></th></tr></thead><tbody><tr><td>0x0000 - 0x007f</td><td>1</td><td>7位二进制（对应ascii标准表的128个字符）转8位2进制，前面加0</td><td>0平面</td></tr><tr><td>0x0080 - 0x07FF</td><td>2</td><td>110xxxxx 10xxxxxx</td><td>0平面</td></tr><tr><td>0x0800 - 0xFFFF</td><td>3</td><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>0平面</td></tr><tr><td>0x010000 - 0x10FFFF</td><td>4</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td><td>1-16平面</td></tr><tr><td>2，3，4字节的转换方法一样，设字节数为n，在第一个字节前面加n个1，n+1位上加个0(也就是紧跟着加个0)，后面的字节均加10.</td><td></td><td></td><td></td></tr></tbody></table><ul><li><p>unicode 转 utf8 </p><p>例“朱” unicode 码点 0x6731,按规则，转3个字符， 转2进制110 011100 110001;长度不够，先在前面补0 -&gt; 0110 011100 110001；再根据规则补：<br>1110 0110 10 011100 10 110001；最后转成16进制utf-8的字节序为e6 9c b1</p></li></ul></li><li><p>UTF-16编码</p><ul><li><p>编码规则</p><table><thead><tr><th>unicode code point</th><th>存储字节数</th></tr></thead><tbody><tr><td>0x0000 - 0xffff</td><td>2个字节</td></tr><tr><td>0x010000 - 0x10ffff</td><td>4个字节</td></tr></tbody></table></li><li><h4 id="高低位"><a href="#高低位" class="headerlink" title="高低位"></a>高低位</h4><p>  在unicode 0平面中有一个码段未被使用，utf-16利用了这一码段。<br>  0xd800 - 0xdfff ,一共2048个码点。<br>  高位 0xd800 - 0xdbff,1024个<br>  低位 0xdc00 0 0xdfff,1024个</p></li><li><p>utf-16编码与unicode的码点的对应关系：  </p><p>  2个字节的，与0平面一一对应。<br>  4个字节的，使用高低位组合：<br>  高位与低位可以组合出1024*1024 = 1048576个编码<br>  而除了0平面，码点范围0x010000 - 0x10ffff的码点正好也是1048576<br>  所以，utf16用高低位4个字节与unicode的非0平面作了一一对应。<br>  所以，当uft16编码中遇到高位编码肯定不是代表某个字符，因为码位上没有字符，而且高位的后边一定会跟着一个低位编码，这样就成了一个4字节编码。然后通过公式找到unicode码位。</p></li><li><p>utf-16与unicode的转换</p><p>  2个字节的直接相等。<br>  4个字节的：<br>  高位 Math.floor((codePoint - 0x010000) / 0x400) + 0xd800<br>  低位 (codePoint - 0x010000)%0x400 + 0xdc00  </p><p>  例：𝌆 unicode code point u+1d306<br>  高位 Math.floor((0x1d306 - 0x010000) / 0x400) + 0xd800 =0xd834<br>  低位 (0x1d306 - 0x010000) % 0x400 + 0xdc00 = 0xdf06<br>  utf16编码为 0x d834 df06</p></li></ul></li></ul></li></ol><ol start="3"><li><h3 id="输入码-区位码-国标码-机内码"><a href="#输入码-区位码-国标码-机内码" class="headerlink" title="输入码, 区位码, 国标码, 机内码"></a>输入码, 区位码, 国标码, 机内码</h3><ul><li>输入码，就是各种中文输入法</li><li>区位码，橫94区纵94位映射的中文字符集 gb2312</li><li>国标码，GB 18030-2005。</li><li>机内码，十六进制的码位（码点 code-point）。</li></ul></li><li><h3 id="bom字符（字节序）了解更多-2-3"><a href="#bom字符（字节序）了解更多-2-3" class="headerlink" title="bom字符（字节序）了解更多 2 3"></a>bom字符（字节序）<a href="http://unicode.org/faq/utf_bom.html#BOM">了解更多</a> <a href="http://7567567.blog.51cto.com/706378/641744">2</a> <a href="http://www.cnblogs.com/flysnail/archive/2011/10/25/2223721.html">3</a></h3><ul><li><p>bom字符，表明该文件的编码方式；存放于文档头</p><table><thead><tr><th>字节</th><th>编码格式</th></tr></thead><tbody><tr><td>00 00 FE FF</td><td>UTF-32BE</td></tr><tr><td>FF FE 00 00</td><td>UTF-32LE</td></tr><tr><td>FE FF</td><td>UTF-16BE</td></tr><tr><td>FF FE</td><td>UTF-16LE</td></tr><tr><td>EF BB BF</td><td>UTF-8</td></tr></tbody></table></li></ul></li></ol><pre><code>utf-8中，以单字节（8bit)为编码单位，&quot;357\273\277&quot;用8进制表示的；读取异常可以删掉。地超过1字节的编码方案中，utf16,32；bom是必须的，分为大端序，小端序。  大端字节序，高字节存于内存低地址，低字节存于内存高地址；小端字节序反之。   例：  &quot;𝌆&quot;字，unicode codePoint : u+1d306,   utf-16编码为:0x d8 34 df 06, 占四字节  大端序 d8 34 df 06 , 小端序 06 df 34 d8  为啥要这么搞，因为win是小端序，mac用大端序。  所以才搞个bom告诉你，你要怎么读这个文件。</code></pre><ol start="4"><li><h3 id="javascript相关字符的问题"><a href="#javascript相关字符的问题" class="headerlink" title="javascript相关字符的问题"></a>javascript相关字符的问题</h3><ul><li><p>javascript允许直接使用codePoint表示字符。<br>  es6前支持utf-16；0平面使用 \u&lt;4位codePoint&gt;<br>  非0平面的字符可以使用高低位，如：<br>  𝌆  “\ud834\udf06”;<br>  如何转? </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, x = <span class="string">"a中𝌆"</span>, output = [];</span><br><span class="line"><span class="keyword">while</span> (i &lt; x.length)&#123;</span><br><span class="line"><span class="keyword">let</span> codePoint = x[i].charCodeAt().toString(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(codePoint&lt;<span class="number">127</span>)&#123;</span><br><span class="line">output.push(<span class="string">"\\x"</span> + codePoint);</span><br><span class="line">i++; </span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (codePoint &gt;=<span class="number">0xd800</span> &amp;&amp; codePoint&lt;= <span class="number">0xdbff</span>)&#123;</span><br><span class="line">output.push(<span class="string">"\\u"</span> </span><br><span class="line">+ codePoint.toString(<span class="number">16</span>) </span><br><span class="line">+  <span class="string">"\\u"</span></span><br><span class="line">+  x[++i].charCodeAt().toString(<span class="number">16</span>)</span><br><span class="line">);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">output.push(<span class="string">"\\u"</span> + codePoint.toString(<span class="number">16</span>));</span><br><span class="line">&#125;;</span><br><span class="line">i++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(output.join(<span class="string">""</span>)+ <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>  这个值只能在js里用。html不支持utf-16编码；<br>  html里面直接 “&amp;#” + “𝌆”.codePointAt() + “;”;</p><p>  es6:支持unicode全集, 0平面不变，非0平面用 \u{&lt;4位以上codePoint&gt;}<br>  𝌆 “\ud834\udf06” 或 “\u{1d306}”<br>  所以，”𝌆”.length = 2;<br>  所以，”a中𝌆” 用for in 遍历4次，而for of 遍历3次（es6)  </p><p>  如果字符串范围超出了0平面，那么得到准确的字串的个数可以用           Array.from(str).length;</p><p>  0平面字符处理与非0平面的不同：<br>  “a中”.charAt(1) // 中<br>  “a中”.charCodeAt(1).toString(16) // 4e2d<br>  String.fromCharCode(0x4e2d) // 中</p><p>  “a𝕄”.codePointAt(1) // 1d544<br>  String.fromCodePoint(0x1d544); // 𝕄</p></li><li><p>支持8位的latin-1字符。 用\x&lt;2位codePoint&gt;</p></li></ul></li></ol><ol start="5"><li><h3 id="html-相关字符的问题"><a href="#html-相关字符的问题" class="headerlink" title="html 相关字符的问题"></a>html 相关字符的问题</h3><ol><li><p>支持所有unicode码点；支持10进制和16进制,支持32位<br>中国 = &amp;#20013;&amp;#22269;<br>  = &amp;#x4e2d;&amp;#x56fd;<br>𝕄 = &amp;#120132; = &amp;#x1d544;</p></li><li><p>支持实体, 如空格 &nbsp;</p></li></ol></li><li><h3 id="换行符的问题"><a href="#换行符的问题" class="headerlink" title="换行符的问题"></a>换行符的问题</h3><p> <a href="http://www.cnblogs.com/del/archive/2009/03/06/1404959.html">unicode速查表</a></p><p> 在文本处理中, CR, LF, CR/LF是不同操作系统上使用的换行符。<br> Dos和windows采用回车+换行CR/LF表示下一行,<br> 而UNIX/Linux采用换行符LF表示下一行，<br> 苹果机(MAC OS系统)则采用回车符CR表示下一行.<br> CR，回车控制符。用符号’\r’表示, 十进制ASCII代码是13, 十六进制代码为0x0D;<br> LF，换行控制符。使用’\n’符号表示, ASCII代码是10, 十六制为0x0A.<br> 所以Windows平台上换行在文本文件中是使用 0d 0a 两个字节表示, 而UNIX和苹果平台上换行则是使用0a或0d一个字节表示。</p><p> 还有一些码位能造成换行如：codePoint 2028-202f</p><p> 引发换行用此正则可替换（0平面）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> delControllerSting = <span class="regexp">/[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g</span>;</span><br></pre></td></tr></table></figure></li><li><h3 id="css伪元素content的值"><a href="#css伪元素content的值" class="headerlink" title="css伪元素content的值"></a>css伪元素content的值</h3><p> unicode 0区 e000-f8ff 自行使用区域  Private Use Zone  </p><p> <code>:before {content:&quot;\0020&quot;} //用反斜线+4位16进制,0020是空格</code></p></li><li><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ul><li><p>JSON无法解析</p><blockquote><p>一个json对象的属性包含了另一个json对象的串化，后端要求解析这个属性成为一个大json对象<br>  因为这个属性之前是单独串化的，故引号做了一次转义。<br>  而这次修改后，老数据后端在页面上通过JS变量返回给前台的时候，这个大json以字串返回，但感觉并没有串化，仅仅只是在外加了个单引号（恰好里面都是双引号，json标准格式）;正常应该将转义符再转一次，也就是\变\。<br>  前端处理时，已无法处理。因为仅一次转义符已在script变量定义时消费掉了。双引号被正常解析，如下举例：  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'&#123;"a":"&lt;p style=\"color:red;\"&gt;&lt;/p&gt;"&#125;'</span></span><br><span class="line"><span class="comment">//这是html源码字串，而js获得字串时已解析成</span></span><br><span class="line"><span class="string">'&#123;"a":"&lt;p style="color:red;"&gt;&lt;/p&gt;"&#125;'</span></span><br><span class="line"><span class="comment">//再通过JSON.parse时，color前面的双引号被正常解析，</span></span><br><span class="line"><span class="comment">//故后面的语法全错了。</span></span><br></pre></td></tr></table></figure><blockquote><p>最后将外加的单引号去掉，前端直接获得json对象。<br>  其实后端拍之前串化一次也可以，而不是仅仅外加单引号。<br>  <code>&#39;{&quot;a&quot;:&quot;&lt;p style=\\&quot;color:red;\\&quot;&gt;&lt;/p&gt;&quot;}&#39;</code></p></blockquote><p>  此坑还有个背景，以为是特殊字符导致的。因为json串里有html串，以前经常发生串里有能产生换行的字符导致无法正常解析，恰好这次里面发现了一个\u2003，后来发现并不是它的问题。</p></li></ul></li></ol><h3 id="Nodejs-request-URL-中文乱码"><a href="#Nodejs-request-URL-中文乱码" class="headerlink" title="{Nodejs} request URL 中文乱码"></a>{Nodejs} request URL 中文乱码</h3><p>浏览器端发送请求时, 浏览器已处理过请求中的中文字符; node端需要手动处理: encodeURI(url)，不处理就会出现乱码。</p><h3 id="IE浏览器中文乱码"><a href="#IE浏览器中文乱码" class="headerlink" title="IE浏览器中文乱码"></a>IE浏览器中文乱码</h3><p>ie没有自动编码，在get模式下出现乱码，encodeURI(url)可解</p><h3 id="浏览器直接访问JS文件，-中文乱码"><a href="#浏览器直接访问JS文件，-中文乱码" class="headerlink" title="浏览器直接访问JS文件， 中文乱码"></a>浏览器直接访问JS文件， 中文乱码</h3><p>需要在Ng中配置<code>http{ charset UTF-8;}</code></p><h3 id="kindediter-粘贴html片段后，存为json-string；再parse时异常"><a href="#kindediter-粘贴html片段后，存为json-string；再parse时异常" class="headerlink" title="kindediter 粘贴html片段后，存为json string；再parse时异常"></a>kindediter 粘贴html片段后，存为json string；再parse时异常</h3><p>原因是font-family中有中文字体；中文字体有引号(在innerHTML时被转义&amp;quot),引号在解析的时候变成了双引号与JSON格式中的双引号冲突。</p><ol><li><code>movePastedData()</code> //没改变</li><li><code>_formatHtml()</code> //删除了转义了的中文字体的尾引号<br>这样问题就产生了，最后生成的html符中有一个独立的&amp;quot,parse字串的时候这个被转成”号。<br>最后，将html串的style属性去除。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;warning&quot;&gt;&lt;a href=&quot;#warning&quot; class=&quot;headerlink&quot; title=&quot;warning&quot;&gt;&lt;/a&gt;warning&lt;/h3&gt;&lt;p&gt;后端在往页面上（如js变量,textarea值)串化的json字符串时，一定要再串化一下；否则串化在字串在浏览器处理过&lt;/p&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;encodeURI，encodeURIComponent两个方法的区别？&quot;&gt;&lt;a href=&quot;#encodeURI，encodeURIComponent两个方法的区别？&quot; class=&quot;headerlink&quot; title=&quot;encodeURI，encodeURIComponent两个方法的区别？&quot;&gt;&lt;/a&gt;encodeURI，encodeURIComponent两个方法的区别？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这两个方法是将字符转换是UTF-8编码；以%开头。&lt;br&gt;encodeURI为要的作用是对url中的&lt;strong&gt;不利于传递的字符进行编码&lt;/strong&gt;&lt;br&gt; 像中文字符按照《RFC 1738》规定，汉字必须编码；但怎么编，自行决定。&lt;br&gt; 所以，页面的字符编码与服务器端解码不一样，那么就会得到乱码。&lt;br&gt; encodeURI就是固定使用utf-8的对字串进行编码，但排除了一些字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;encodeURIComponent的作用是如果一个URL里面的&lt;strong&gt;某个参数也是一个url&lt;/strong&gt;&lt;br&gt;这样的话，这个URL就有了二义性，如下：&lt;br&gt;“&lt;a href=&quot;http://www.b.com?a=100&amp;amp;b=www.c.com?y=100&amp;amp;z=200&amp;quot;&quot;&gt;http://www.b.com?a=100&amp;amp;b=www.c.com?y=100&amp;amp;z=200&amp;quot;&lt;/a&gt;&lt;br&gt;所以，当一个url的参数包括另一个url的话，这个作为参数值的url必须encodeURIComponent编码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="web" scheme="1824437.github.io/categories/web/"/>
    
    
      <category term="字符集" scheme="1824437.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    
      <category term="编码" scheme="1824437.github.io/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/shell%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7/"/>
    <id>1824437.github.io/os/shell特殊符号/</id>
    <published>2019-05-09T01:19:58.490Z</published>
    <updated>2019-10-30T00:16:14.612Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>字符</th><th>说明</th><th>用途</th><th>备注</th></tr></thead><tbody><tr><td>&lt;</td><td></td><td></td><td></td></tr><tr><td>&lt;&lt;</td><td></td><td></td><td></td></tr><tr><td>*</td><td></td><td></td><td></td></tr><tr><td>?</td><td></td><td></td><td></td></tr><tr><td>\</td><td></td><td></td><td></td></tr><tr><td>‘</td><td></td><td></td><td></td></tr><tr><td>“</td><td></td><td></td><td></td></tr><tr><td>`…`</td><td></td><td></td><td></td></tr><tr><td>[]</td><td></td><td></td><td></td></tr><tr><td>$</td><td></td><td></td><td></td></tr><tr><td>.</td><td>内置句点</td><td></td><td></td></tr><tr><td>#</td><td></td><td></td><td></td></tr><tr><td>{}</td><td></td><td></td><td></td></tr><tr><td>:</td><td>内置空串</td><td></td><td></td></tr><tr><td>&amp;&amp;</td><td></td><td></td><td></td></tr><tr><td>||</td><td></td><td></td><td></td></tr><tr><td>!</td><td></td><td></td><td></td></tr><tr><td>$()</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>&amp;&amp; 逻辑符号</strong>   </p><p>前面的命令正确, 后面的继续执行</p><p><strong>|| 逻辑符号</strong>  </p><p>前面的命令无效, 后面的执行。</p><p><strong>; 顺序执行</strong></p><p>一个挨一个执行</p><p><strong>&amp; 后台工作</strong> </p><p>单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。</p><p><strong>| 管道 (pipeline)</strong>  </p><p>pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。 </p><p><strong>&gt; 输出到文件</strong><br><code>ls &gt;1.txt</code></p><p><strong>&gt;&gt; 追加到文件</strong><br><code>cat a.txt&gt;&gt;b.txt</code></p><p>-</p><p><strong>伪设备</strong></p><ul><li><p>/dev/null</p><p>  <code>cat a.txt &gt;/dev/null</code> 黑洞，屏幕上不会显示任何信息。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;

      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="linux" scheme="1824437.github.io/tags/linux/"/>
    
      <category term="CentOS" scheme="1824437.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/ssh_linux%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/"/>
    <id>1824437.github.io/os/ssh_linux的远程执行/</id>
    <published>2019-05-09T01:19:58.490Z</published>
    <updated>2019-10-30T00:17:31.379Z</updated>
    
    <content type="html"><![CDATA[<p>references</p><p>完整的server/client配置实践<a href="./git服务部署.md">git服务部署</a></p><p><strong>相关命令</strong></p><p>###ssh  </p><p>用法<a href="http://blog.csdn.net/pipisorry/article/details/52269785">http://blog.csdn.net/pipisorry/article/details/52269785</a></p><p><code>ssh -V</code> 查看ssh版本 </p><ul><li>默认端口: 22</li></ul><p>ssh-keygen</p><p>-</p><h3 id="公钥、私钥"><a href="#公钥、私钥" class="headerlink" title="公钥、私钥"></a>公钥、私钥</h3><p><strong>资料</strong></p><p>数据公钥加密和认证中的私钥公钥<a href="http://www.williamlong.info/archives/837.html">http://www.williamlong.info/archives/837.html</a><br>使用ssh-keygen设置SSH无密码登录<a href="http://blog.csdn.net/leexide/article/details/17252369">http://blog.csdn.net/leexide/article/details/17252369</a><br>Linux ssh服务开启秘钥和密码认证<a href="https://www.cnblogs.com/xiaochina/p/6867298.html">https://www.cnblogs.com/xiaochina/p/6867298.html</a></p><p><strong>公钥,私钥是怎么实现不对称加密的?</strong></p><ol><li>私钥是绝对保密的,私钥用来进行解密和签名, 是给自己用的</li><li>公钥由本人公开，用于加密和验证签名，是给别人用的。</li><li>当该用户发送文件时，用私钥签名，别人用他给的公钥验证签名，可以保证该信息是由他发送的。当该用户接受文件时，别人用他的公钥加密，他用私钥解密，可以保证该信息只能由他接收到。</li></ol><p><strong>安全性</strong></p><p>目前能破解的RSA算法密钥是768个二进制位. 超过此长度的破解无人公开公布过。一般认为1024的密钥基本安全, 2048位的密码极其安全。</p><p><strong>生成公钥,私钥</strong></p><p>ssh-keygen</p><ul><li><p>-t <em>type</em> </p><p>  指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)</p></li><li><p>-p</p><p>  要求改变某私钥文件的密语而不重建私钥。程序将提示输入私钥文件名、原来的密语、以及两次输入新密语。</p></li></ul><p><code>ssh-keygen -t rsa</code> 生成本机的公私钥</p><p><strong>.ssh目录及文件</strong></p><ol><li><p>known_hosts文件</p><p> 记录访问过的主机的公钥</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.237.72 ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAppBeLNHwpSlWGtLMeW0SpJ0TQs8qyHWxyBxh1JM8b9mJgvsRj8/xUDjcDgC59xXQkeX37Hp4DtlWz4bwkR4im5WLQ3QVj0YSw/1WrB/x/TNhHWvFMP8IXi18ZfTuCtBTufZZzt0ZPFkbioKVf4hg3ukEXIhxYlRaByhb/2U22rBdImGAkq6tV7ZPvemfcTtrU+QLv61+mQoDOkbobOvbgSPlU3eH4CWED4bQ5C3oIlpGFLSjcYnslHwnCzFUsh1d/YH4Jpt6lX5kPzZFSRQVjqI8ucrLVhsQvtERKOzjQh3i611WbZB8Rn7dUS2jIWk5egUQPJ+bhDbGd9DqZ1th3Q==</span><br></pre></td></tr></table></figure></li><li><p>客户端配置文件</p><ul><li><p>/etc/ssh_config 全局配置</p></li><li><p>.ssh/config 本地配置</p><p>本地配置优先级高于全局配置 </p></li></ul><p> <strong>配置项</strong></p><ul><li><p>Host  主机配置（也是分段标志,接下了的配置就是和这个主机配置相关的，直到碰到另一个Host)</p><p>  <code>Host &lt;string&gt;</code><br>  <code>Host www.x.cn</code> domain<br>  <code>Host 123.123.123.123</code>ip<br>  <code>Host 123.123.*</code> 通配符<br>  <code>Host dev1</code> 别名<br>  <code>HostName www.x.cn</code><br>  <code>port 27155</code><br>  <code>User git</code>  </p></li><li><p>IdentityFile 用户身份标识</p><p>  <code>IdentifyFile &lt;private key file&gt;</code></p><p>  command mode: <code>ssh -i ~/.ssh/id_rsa 10.86.211.11</code>用私钥登录</p></li></ul></li></ol><pre><code>+ ProxyCommand     看不太懂，link先记下    [SSH ProxyCommand 实践 ](https://www.cnblogs.com/shanpow/p/4264867.html)配置详情参阅:《SSH权威指南》客户端的配置(page 280)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># generated by qzz-copy-id</span><br><span class="line">Host *</span><br><span class="line">    User tao.zhu</span><br><span class="line"></span><br><span class="line">Host *</span><br><span class="line">User tao.zhu</span><br><span class="line">ServerAliveInterval 30</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/.ssh/persist/master-%r@%h:%p</span><br><span class="line">ControlPersist yes</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>authorized_keys 文件</p><p> 服务器保存客户机的公钥。<br> 把自己的公钥放在服务器上的.ssh/authorized_keys文件内后，可直接ssh</p></li><li><p>/etc/ssh/moduli</p></li><li><p>/etc/ssh/ssh_config  存放作为客户端的一些ssh配置</p></li><li><p>etc/ssh/sshd_config 存放作为服务器端的一些ssh配置  </p></li></ol><h4 id="重新生成公钥后要干的事"><a href="#重新生成公钥后要干的事" class="headerlink" title="重新生成公钥后要干的事"></a>重新生成公钥后要干的事</h4><p>git SSH keys 重新设置<br>ssh 免登录主机重新设置</p><p><strong>注意 注意 注意</strong><br><strong>设置免密登录时，必须要保证被登录服务器用户的.ssh文件夹及下的authorized_keys文件除本用户的其它用户无写权限，否则免密登录不生效</strong><br><strong>还要密切注意服务器上/etc/ssh/sshd_config的下列字段必须打开</strong></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile.ssh/authorized_keys</span><br></pre></td></tr></table></figure></code></pre><blockquote><p><a href="https://www.cnblogs.com/snowbook/p/5671406.html">引用网文</a><br>后来，我详细查了一下，如果authorized_keys文件、$HOME/.ssh目录 或 $HOME目录让本用户之外的用户有写权限，那么sshd都会拒绝使用 ~/.ssh/authorized_keys 文件中的key来进行认证的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;references&lt;/p&gt;
&lt;p&gt;完整的server/client配置实践&lt;a href=&quot;./git服务部署.md&quot;&gt;git服务部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;###ssh  &lt;/p&gt;
&lt;p&gt;用法&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="linux" scheme="1824437.github.io/tags/linux/"/>
    
      <category term="远程执行" scheme="1824437.github.io/tags/%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/mac/"/>
    <id>1824437.github.io/os/mac/</id>
    <published>2019-05-09T01:19:58.489Z</published>
    <updated>2019-10-30T00:16:52.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><a href="https://jingyan.baidu.com/article/20095761ce2b4fcb0621b453.html">https://jingyan.baidu.com/article/20095761ce2b4fcb0621b453.html</a></p><ul><li><p>~/Applications </p><p>  包含一些只有当前用户可以使用的程序，比如我们安装了一个程序，安装时选Applications，应用程序将会默认安装到这里！</p></li><li><p>~/Documents 文稿</p></li><li><p>~/cert</p></li><li><p>~/etc</p></li><li><p>~/Libary 包括应用程序设置、预置及其它用户指定的系统资源或设置。</p></li><li><p>~/Public 你可以把需要与其它用户共享的文件放在这个目录中，默认状态下，这个目录可以被其它所有用户访问。</p></li><li><p>~/Desktop 桌面</p></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/profile #全局配置，登录时默认读取（all users）<br>/etc/paths # 全局配置，登录时默认读取（all users）<br>/etc/bashrc #全局配置，bash shell执行时会读取（all users ）<br><del>/.bash_profile #当前用户配置，存在此文件则忽略</del>/.bash_login,<del>/.bashrc，通常该配置文件还会配置成去读取</del>/.bashrc。<br><del>/.bash_login #当login的方式执行时，并且无</del>/.bash_profile时，读取此文件<br><del>/.profile #若</del>/.bash_profile,~/.bash_login都不存在讲，读取此文件；<br>~/.bashrc #以non-login执行时，会执行此文件<br>~/.bash_logout #退出bash时，执行此文件  </p><h3 id="安装app影响的目录"><a href="#安装app影响的目录" class="headerlink" title="安装app影响的目录"></a>安装app影响的目录</h3><p>~/Library</p><p>~/Library/Application Support</p><p>~/Library/Application Support/CrashReporter</p><p>~/Library/Caches</p><p>~/Library/Containers</p><p>~/Library/LaunchAgents</p><p>~/Library/Preferences</p><p>~/Library/PreferencePanes</p><p>/Library<br>/Library/Application Support<br>/Library/Extensions<br>/Library/LaunchAgents<br>/Library/LaunchDaemons<br>/Library/PreferencePanes<br>/Library/Preferences  </p><p>一般来说/etc下一般是系统全局性的公共文件目录，而/usr/local/etc下一般指代用户级的公共文件目录。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ol><li><p>osx默认应用程序来源于store或store及信任的开发者，如需”所有来源”选项，则停用Gatekeeper。<br> <code>sudo spctl --master-disable</code><br> <code>sudo spctl --master-enable</code></p></li><li><p><code>sudo killall -HUP mDNSResponder</code> </p></li></ol><h3 id="LF-CRLF"><a href="#LF-CRLF" class="headerlink" title="LF, CRLF"></a>LF, CRLF</h3><p>##系统异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br><span class="line">Error: Failure while executing: git config --local --replace-all homebrew.private true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法：</span><br><span class="line">终端执行sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer命令，然后再输入一次系统的密码，完成。</span><br></pre></td></tr></table></figure><p>-</p><ol><li><p>安装iterm2</p><ul><li><a href="http://www.iterm2.com下载安装">www.iterm2.com下载安装</a></li><li><a href="http://iterm2colorschemes.com/">http://iterm2colorschemes.com/</a> 下载配色并导入。</li></ul></li><li><p>安装nvm</p><ul><li><a href="https://github.com/creationix/nvm下载安装">https://github.com/creationix/nvm下载安装</a></li><li>创建~/.bashrc文件(如果没有的话)</li><li>或直接<code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></li><li>source ~/.bashrc</li></ul></li><li><p>用nvm安装nodejs</p><p> 每个版本下都得重新装一遍nodejs应用。</p></li><li><p>安装brew</p><p> <code>/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code><br> 会自动装上command line tools for xcode</p></li><li><p>安装git</p><p> <code>brew install git</code></p></li><li><p>finder显示所有文件夹</p><p> <code>defaults write com.apple.finder AppleShowAllFiles -bool true;KillAll Finder</code></p></li><li><p>配置git，配色方案，命令行等</p></li></ol><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#load .bashrc</span><br><span class="line"><span class="keyword">if</span> [ -f ~<span class="regexp">/.bashrc ];then</span></span><br><span class="line"><span class="regexp"> . ~/</span>.bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#git配置</span><br><span class="line">. /usr/local/Cellar/git/2.16.2/etc/bash_completion.d/git-completion.bash #自动补全</span><br><span class="line">. /usr/local/Cellar/git/2.16.2/etc/bash_completion.d/git-prompt.sh #分支信息</span><br><span class="line"><span class="keyword">export</span> GIT_PS1_SHOWDIRTYSTATE=<span class="number">1</span></span><br><span class="line">#带分支信息，多色提示符</span><br><span class="line"><span class="keyword">export</span> PS1=<span class="string">'\n\[\033[32m\]\u@\h\[\033[33m\]\w\[\033[36m\]$(__git_ps1 " (%s)")\[\033[0m\]\n\$ '</span></span><br><span class="line"></span><br><span class="line">#终端配色方案</span><br><span class="line"><span class="keyword">if</span> brew list | grep coreutils &gt; <span class="regexp">/dev/</span><span class="literal">null</span> ; then</span><br><span class="line">  PATH=<span class="string">"$(brew --prefix coreutils)/libexec/gnubin:$PATH"</span></span><br><span class="line">  alias ls=<span class="string">'ls -F --show-control-chars --color=auto'</span></span><br><span class="line">  <span class="built_in">eval</span> <span class="string">`gdircolors -b $HOME/.dir_colors`</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></code></pre><ol start="8"><li><p>安装beyond compare 4 ,并配置到git </p><ul><li><p><code>rm &quot;/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat&quot;</code> 过期删除此文件</p></li><li><p>配置git</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[diff]</span><br><span class="line"> tool = bc</span><br><span class="line"> [difftool]</span><br><span class="line">     prompt = false</span><br><span class="line"> [difftool &quot;bc&quot;]</span><br><span class="line"> path = /usr/local/bin/bcomp</span><br><span class="line"> [merge]</span><br><span class="line"> tool = bc</span><br><span class="line"> [mergetool &quot;bc&quot;]</span><br><span class="line"> path = /usr/local/bin/bcomp</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="8"><li><p>安装 adobe acrobat reader</p></li><li><p>安装 reeder 3 for mac(下载破解)</p></li><li><p>安装 switchhosts</p></li><li><p>安装 charles</p></li><li><p>安装 yarn</p><p><code>brew install yarn --without-node</code><br>如果安装不成功，可能是gz包下载失败(资源被重定向了)，解决:</p><ul><li><code>brew --cache</code>查看cache目录</li><li>手动下载定向后的包放在这个文件夹。</li><li>brew安装时会去cache里面找包名，找到后直接安装。</li></ul></li><li><p>安装 nginx <code>brew install nginx</code></p></li><li><p>安装工程环境（node)</p><ul><li>ykit</li></ul></li></ol><ol><li>aria2</li><li>alfred</li></ol><h3 id="install-shadowsocks-client"><a href="#install-shadowsocks-client" class="headerlink" title="install shadowsocks client"></a>install shadowsocks client</h3><p>-</p><p>which aria2c 可以看到可执行文件在哪个目录  </p><p>ls -la /usr/local/bin/aria2c 可以看到软连接指向哪个目录</p><p>brew 安装的软件都在/usr/local/Cellar 这个目录下</p><p>-</p><h2 id="mac-命令"><a href="#mac-命令" class="headerlink" title="mac 命令"></a>mac 命令</h2><ul><li><p><code>networksetup -listallhardwareports</code>    列出所有接口</p></li><li><p>open . #打开当前目录的finder</p><p> <code>open -a &lt;app&gt; &lt;filename&gt;</code>    用某程序打开某文件</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jingyan.baidu.com/article/20095761ce2b4fcb062
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="Mac" scheme="1824437.github.io/tags/Mac/"/>
    
      <category term="OSX" scheme="1824437.github.io/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/centos%E5%90%8C%E6%AD%A5%E6%96%87%E4%BB%B6/"/>
    <id>1824437.github.io/os/centos同步文件/</id>
    <published>2019-05-09T01:19:58.489Z</published>
    <updated>2019-10-30T00:15:30.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a><a href="https://www.samba.org/ftp/rsync/rsync.html">rsync</a></h2><p><a href="http://www.cnblogs.com/f-ck-need-u/p/7221713.html">参数详解</a></p><h3 id="同步文件的模式"><a href="#同步文件的模式" class="headerlink" title="同步文件的模式"></a>同步文件的模式</h3><ol><li>检查模式</li><li>同步模式</li></ol><h3 id="工作方式-3种"><a href="#工作方式-3种" class="headerlink" title="工作方式 3种"></a>工作方式 3种</h3><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><blockquote><p>同步是<strong>增量的! 增量的! 增量的！</strong>，即使<code>-R</code>在目标文件夹内创建文件夹也不会将已存在的同名文件夹内容清除</p></blockquote><p><strong>options</strong></p><ul><li><p><code>-r</code> 此选项告诉rsync以递归模式拷贝目录。</p><p>  不带r只能同步文件，如果不带r 同步目录则不会干活，提示<code>skipping directory .</code></p></li></ul><p><strong>eg</strong></p><blockquote><p>带和不带尾<code>/</code>是有区别的。 </p></blockquote><p><code>rsync -r ./from ./to</code> //这样写会把from 同步到to, to会生成一个from<br><code>rsync -r ./from/ ./to</code> //这样写会把from里的所有(file,directory)同步到to</p><p><strong>options</strong></p><ul><li><code>-R</code> 表示需要将源路径上的目录创建在目标文件夹内（所建文件夹的所有下级都会被增量复制)</li></ul><p><strong>eg</strong>  </p><p><code>rsync -R from/abc/a.txt /to</code> 同步a.txt，并创建from,abc文件夹。<br><strong>如果只复制路径的一部分则：用<code>.</code>隔开</strong><br><code>rsync -R from/./abc/a.txt /to</code> 同步a.txt, 并创建abc文件夹。</p><p><strong>options</strong></p><ul><li><p><code>--backup</code> 对目标文件夹内的<strong>相同的文件</strong>做备份</p><p>  备份默认使用<code>~</code>,可以使用<code>--suffix &lt;symbol&gt;</code><br>  <code>rsync -ri --backup --suffix=% from/ to</code><br>  也可以指定备份的路径，但路径必须存在.<code>--backup-dir=./to_back</code></p></li></ul><h4 id="不同主机同步"><a href="#不同主机同步" class="headerlink" title="不同主机同步"></a><strong>不同主机同步</strong></h4><p><strong>options</strong></p><ul><li><p><code>-e</code>指定所要使用的远程shell程序，默认为ssh</p><p>  <code>rsync -ir -e &quot;ssh -p 1080&quot; from/static t.z@138.128.197.152:~/static</code><br>  注意: 我的web root 是<code>/home/www/static</code>，但t.z没有w权限，所以先暂存到有权限的<code>~</code>下，然后在通过<code>sudo rsync -ri ~/static/ /home/www/static</code></p></li></ul><p><strong>options</strong></p><ul><li><code>--existing</code> 只更新目标端已存在的文件</li><li><code>--ignore-existing</code> 只更新目标端不存在的文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;rsync&quot;&gt;&lt;a href=&quot;#rsync&quot; class=&quot;headerlink&quot; title=&quot;rsync&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.samba.org/ftp/rsync/rsync.html&quot;&gt;rsync&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="linux" scheme="1824437.github.io/tags/linux/"/>
    
      <category term="rsync" scheme="1824437.github.io/tags/rsync/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/mac%E5%88%B6linux%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    <id>1824437.github.io/os/mac制linux启动盘/</id>
    <published>2019-05-09T01:19:58.489Z</published>
    <updated>2019-10-30T00:18:04.181Z</updated>
    
    <content type="html"><![CDATA[<p>在Mac环境下，将Linux的ISO镜像生成一个Linux的安装盘，和Linux下差不多，只是Mac下有一些自己的工具。</p><p>步骤如下：</p><p>1、在终端下，将ISO镜像转换为DMG格式：</p><p><code>$ hdiutil convert -format UDRW -o ~/linux.dmg /tmp/linux.iso</code></p><p>2、插入USB盘，然后在终端下，查找该盘的设备名：</p><p>$ diskutil list<br>/dev/disk0<br>  #:                      TYPE NAME                    SIZE      IDENTIFIER<br>  0:      GUID_partition_scheme                        *121.3 GB  disk0<br>  1:                        EFI                        209.7 MB  disk0s1<br>  2:                  Apple_HFS Macintosh HD            120.5 GB  disk0s2<br>  3:                Apple_Boot Recovery HD            650.0 MB  disk0s3<br>/dev/disk1<br>  #:                      TYPE NAME                    SIZE      IDENTIFIER<br>  0:    FDisk_partition_scheme                        *15.8 GB    disk1<br>  1:              Windows_NTFS wxy-u3                  15.8 GB    disk1s1</p><p>以上显示该盘的设备名是： /dev/disk1</p><p>也可以通过“磁盘工具”里面选择磁盘（不是分区），来查看其信息，获得设备名。</p><p>3、卸载USB盘（插入时已经自动挂载了），但是不要推出。在终端下：</p><p>$ diskutil umountDisk /dev/disk1<br>Unmount of all volumes on disk1 was successful</p><p>也可以通过“磁盘工具”进行卸载。</p><p>4、镜像上面生成的DMG内容到USB盘，在终端下：</p><p>$ sudo dd if=linux.dmg of=/dev/rdisk1 bs=1m<br>Password:<br>2151+1 records in<br>2151+1 records out<br>2256076800 bytes transferred in 90.277905 secs (24990354 bytes/sec)</p><p>此处要千万注意，指定的of别写错了，否则悔之晚矣。另外，of参数指定的设备名，可以用上面找到的/dev/disk1，也可以用/dev/rdisk1，此处的“r”据说会写入较快。</p><p>另外，如果报错：“dd: Invalid number `1m’”，可能是使用的不同版本的dd，可以换为bs=1M试试。</p><p>如果报错：“dd: /dev/diskN: Resource busy”，可能是上面的步骤中没有完成卸载USB盘。</p><p>5、推出USB盘。在上面复制之后，系统可能会报错，“此电脑不难读取能插入的磁盘”，不必理会，直接推出即可。也可以在终端下推出：</p><p>$ diskutil eject /dev/disk1</p><p>或者在“磁盘工具”里面推出。</p><p>使用该USB盘引导启动即可进行Linux的安装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Mac环境下，将Linux的ISO镜像生成一个Linux的安装盘，和Linux下差不多，只是Mac下有一些自己的工具。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;p&gt;1、在终端下，将ISO镜像转换为DMG格式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ hdiutil convert -f
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="linux" scheme="1824437.github.io/tags/linux/"/>
    
      <category term="启动盘" scheme="1824437.github.io/tags/%E5%90%AF%E5%8A%A8%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CentOS学习</title>
    <link href="1824437.github.io/os/shell_command/"/>
    <id>1824437.github.io/os/shell_command/</id>
    <published>2019-05-09T01:19:58.489Z</published>
    <updated>2019-10-30T00:18:53.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li><p>常见缩写</p><ul><li>UID : 用户ID</li><li>EUID : 用于判断对系统资源的访问权限</li><li>GID : 用户所属组</li><li>PID : 进程</li><li>PPID : 父进程</li><li>PGID : 进程所属组</li></ul></li><li></li></ol><h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><h3 id="cp-xxd-sed-curl-ssh-keygen-lsof-ps-traceroute-chmod-tail"><a href="#cp-xxd-sed-curl-ssh-keygen-lsof-ps-traceroute-chmod-tail" class="headerlink" title="cp xxd sed curl ssh-keygen lsof ps traceroute chmod tail"></a><a href="#cp">cp</a> <a href="#xxd">xxd</a> <a href="#sed">sed</a> <a href="#crul">curl</a> <a href="#ssh-keygen">ssh-keygen</a> <a href="#lsof">lsof</a> <a href="#ps">ps</a> <a href="#traceroute">traceroute</a> <a href="#chmod">chmod</a> <a href="#tail">tail</a></h3><x id="cp"><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>文本，目录复制</p><ul><li>参数<ul><li>-v 显示过程</li><li>-r 复制目录<br><code>cp ./wp ./wps -r</code><br>复制wp下的文件及子文件夹到 wps</li></ul></li></ul><x id="xed"><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>在线编辑器</p><ul><li>参数<ul><li>-n 仅显示script后的结果<br>  <code>sed -n</code>  </li><li>l 列出不能打印字符的清单<br>  <code>sed l</code></li></ul></li></ul><x id="xxd"><h3 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h3><p>作为16进制的输出</p><ul><li>参数<ul><li>-b 用二进制显示<br><code>xxd -b</code></li></ul></li></ul><x id="crul"><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>文件传输工具</p><ul><li><p>参数 </p><ul><li><p>-s / -silent 静音模式，不输出任何东西。<br>  <code>curl -s https://www.baidu.com | head -1</code><br>  只输出第一行。<br>  <code>curl -s https://www.baidu.com | head -1 | xxd</code><br>  用十六进制输出1行<br>  <code>curl -s https://www.baidu.com | head -1 | sed -n l</code><br>  输出1行，并输出不能打印的字符</p><p><code>curl &#39;&lt;url&gt;&#39; -H &#39;Accept: application/json&#39; -H &#39;Cookie: &lt;cookie&gt;&#39;</code><br>带cookie访问  </p></li></ul></li></ul><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><x id="ssh-keygen"><h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h3><p>生成密钥。<br>免密登录：<br>    1. 可以生成公私钥。rsa , rsa.pub两个文件。<br>    2. 登录某台需免密的机器。将rsa.pub的文件内容粘贴到.ssh</p><x id="lsof">### lsof<p>用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件</p><ul><li><p>-c <process name> 指定进程名</p></li><li><p>-p <pid> 指定进程名</p></li><li><p>-i <condition> 指定条件</p><p> <code>lsof -i 4</code>  查询使用第4版ip协议的进程<br> <code>lsof -i :80</code>  查询监听80端口的进程<br> <code>lsof -i @127.0.0.1</code> 查询监听本机的进程<br> <code>lsof -i tcp</code> 查询使用tcp协议的进程</p></li></ul><x id="ps">### ps <p> 有时候系统管理员可能只关心现在系统中运行着哪些程序，而不想知道有哪些进程在运行。由于一个应用程序可能需要启动多个进程。所以在同等情况下，进程的数 量要比程序多的多。为此从阅读方面考虑，管理员需要知道系统中运行的具体程序。要实现这个需求的话，就需要利用命令ps来帮忙。<br>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多 的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p><strong>ps可显示的所有字段</strong></p><p><code>ps -o &quot;user,pid,args,rss&quot;</code></p><ul><li>user 用户名</li><li>uid 用户号</li><li>pid 进程号</li><li>ppid 父进程号</li><li>size 内存大小, Kbytes字节.</li><li>vsize 总虚拟内存大小, bytes字节(包含code+data+stack)</li><li>share 总共享页数</li><li>nice 进程优先级(缺省为0, 最大为-20)</li><li>priority(pri) 内核调度优先级</li><li>pmem 进程分享的物理内存数的百分比</li><li>pcpu 占用的cpu百分比</li><li>trs 程序执行代码驻留大小</li><li>rss 进程使用的总物理内存数, Kbytes字节</li><li>time 进程执行起到现在总的CPU暂用时间</li><li>stat 进程状态</li><li>cmd(args) 执行命令的简单格式</li></ul><p>-</p><ul><li><p>查看 所有的进程</p><p>  <code>ps -A</code></p></li><li><p>查看指定用户的进程</p><p>  <code>ps -u root</code></p></li></ul><p>主要应用<br><code>ps aux</code> 列表所有程序及进程</p><x id="nslookup">### nslookup 查服务器名`nslookup 10.86.44.130`<x id="tail">### tailtail命令用于输入文件中的尾部内容。<ul><li>-c <em>num</em> 指定尾部多少行</li><li>-f/–follow 显示文件追加的内容</li></ul><p><code>tail -f /tmp/access.log</code> 查看日志，并监控文件尾部增加 </p><x id="echo">### echo<p>参数含义<br>显示方式    意义<br>0    终端默认设置<br>1    高亮显示<br>4    使用下划线<br>5    闪烁<br>7    反白显示<br>8    不可见<br>前景色    背景色    颜色<br>30    40    黑色<br>31    41    红色<br>32    42    绿色<br>33    43    黃色<br>34    44    蓝色<br>35    45    紫红色<br>36    46    青蓝色<br>37    47    白色</p><ul><li>要打彩色注意与串中间加空格。<br><code>echo -e &quot;\033[4;40;37m 黑底白字 \033[0m&quot;</code></li></ul><x id="scp">### scp <p>linux之间复制文件</p><p><code>scp tao.zhu@192.168.237.21:~/a/temp.json ~</code></p><ul><li><p>-r 递归复制整个目录</p><p>  <code>scp -r l-rtools1.ops.cn5:~/a ~/.ssh</code> 将cn5主机下<del>/a文件夹递归复现到本机的</del>/.ssh文件夹下</p></li></ul><x id="traceroute">### traceroute<p>查看数据包到主机的路径</p><x id="chmod">### chmod 权限操作命令<p>权限基础<br><img src="_source/chmod1.png" alt=""><br>第一列，权限列 ，10-12个字符组成</p><p>第1个字符：文件类型，字符含义：</p><p><img src="_source/chmod2.png" alt=""></p><p>第2-4（文件所有者）<br>5-7（文件所有者所在的组）<br>8-10（其它人）的权限；<br>三个权限字符分别代表读取，写入，执行权限。<br>权限代号表  </p><table><thead><tr><th>类型</th><th>字母</th><th>数字</th></tr></thead><tbody><tr><td>读取</td><td>r</td><td>4</td></tr><tr><td>写入</td><td>w</td><td>2</td></tr><tr><td>执行</td><td>x</td><td>1</td></tr><tr><td>无权</td><td>-</td><td>0</td></tr><tr><td>还有s,当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限。（待理解）</td><td></td><td></td></tr></tbody></table><p>如一个文件，所有者有3权，其组有读权，其他人无权，应该显示<br>-rwxr–r–</p><p>第11个字符表示acl和selinux属性<br>第12个字符是个结尾符</p><h3 id="查看文件夹占用的磁盘空间"><a href="#查看文件夹占用的磁盘空间" class="headerlink" title="查看文件夹占用的磁盘空间"></a>查看文件夹占用的磁盘空间</h3><p><code>du -sh</code></p><h3 id="adduser-useradd-创建用户"><a href="#adduser-useradd-创建用户" class="headerlink" title="adduser/useradd 创建用户"></a>adduser/useradd 创建用户</h3><p><a href="http://www.cnblogs.com/the-tops/p/5632828.html">infos</a></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>mv 文件改名</p><h3 id="删除用户x"><a href="#删除用户x" class="headerlink" title="删除用户x"></a>删除用户x</h3><ol><li><code>user del x</code></li><li><code>rm -rf /home/x</code></li><li><code>rm -rf /var/spool/mail/x</code></li></ol><h3 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h3><pre><code>`rpm -qi centos-release`</code></pre><h3 id="常用检测进程命令"><a href="#常用检测进程命令" class="headerlink" title="常用检测进程命令"></a>常用检测进程命令</h3><p>1.先使用ps -e | grep nginx查看是否已经启动了nginx</p><p>2.如果没有的话则按照提示，查看0.0.0.0:80端口谁占用了，使用netstat -ltunp命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;常见缩写&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UID : 用户ID&lt;/li&gt;
&lt;li&gt;EUID : 用于判断对系统资
      
    
    </summary>
    
    
      <category term="os" scheme="1824437.github.io/categories/os/"/>
    
    
      <category term="linux" scheme="1824437.github.io/tags/linux/"/>
    
      <category term="shell" scheme="1824437.github.io/tags/shell/"/>
    
  </entry>
  
</feed>
